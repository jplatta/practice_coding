# Chapter 1: Object-Oriented Design

* Change to your program is inevitable.
* OO applications are made up of parts, called *objects*, that interact with each other in the form of *messages* that pass between them.
* OO design is about *managing dependencies*. This means coding in way that organizes the dependencies of objects so that they can tolerate change. 
* Practical design assumes that your application will change and aims to *(1)* allow you to continue to make future designs decisions while *(2)* reducing the cost of changing the application to implement those future decisions. 
* SOLID:
    * **S**ingle Responsibility
    * **O**pen-Closed
    * **L**iskov Substitution
    * **I**nterface Segregation
    * **D**ependency Inversion
* DRY: Don't repeat yourself.
* LoD: Law of Demeter
* *Agile believes that your customers can't define the software they want before seeing it, so it's best to show them sooner rather than later. [...] It follows that you should build software in tiny increments, gradually iterating your way into an application that meets the customer's true need.*
* The ultimate software metric would be *cost per feature over the time interval that matters*
* Technical debt: 
    * Making a design decision that attains some immediate value, e.g. some business milestone, in exchange for lengthier follow-up work.
    * Given two designs, X and Y, X has greater technical debt than Y if X will lead to more future work than Y, but X has a shorter time to implementation than Y.
* Procedural languages v. object-oriented languages (p. 12)
